\documentclass[letterpaper, 12pt]{article}
\usepackage{palatino}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=1.5cm,includefoot]{geometry}
\usepackage{multicol}
\usepackage[mathscr]{eucal}
\usepackage{wrapfig}

\title{Thirdmode Store Administrator Guide}
\author{Michael Schmitz\\
        Thirdmode Web Projects
}
\date{\today}
\begin{document}

\maketitle
% \begin{multicols}{2}

\tableofcontents

\section{Introduction}
The {\em Thirdmode Store, or TMS for short,} is a web site construction framework for medium or large commercial web sites.  Like all online stores there are actually two web sites, the customer web site, and the administrative web site.  The customer web site presents products, methods to navigate, search, sort, and filter search results, a shopping cart, a login and password recovery process, a checkout and payment process, and an order status view.  The administrative web site is designed so that after an intial setup phase (that may involve a programmer and a CSS designer), a merchant with little or no technical experience can take over the ongoing maintenance.   The merchant can define categories, navigation tabs, product families, product attributes, and products and edit these objects and their relationships.  These operations can target large numbers of objects at once, so tedious one-at-a-time operations are avoided.  Further, these operations enforce logical and systematic organization of the objects.  Finally, the results of these operations are immediately visible on the customer web site.

There is also basic support for back-office procedures.  Through PayPal Pro, authorization, full or partial capture, voiding an authorization, full or partial refund of a sale, reauthorization, and ayschronous notifications are all supported.  The merchant can view all orders and sort them in various ways, or select only those that are in ``OK to Ship'' status.  Email alerts can be set up for customer initiated disputes, inventory-low warnings and so forth.  TMS is also integrated with UPS, so that exact shipping options and costs can be presented to the customer during the checkout process.  PayPal standard is also supported, and there is also some support for the Braintree payment gateway.

TMS is delivered as a {\em Ruby on Rails} application.  The setup phase can become very involved depending on the merchant requirements.  Perhaps integration with an existing Oracle (or non-Oracle) database is required, perhaps the merchant wants to use an Oracle RAC cluster, perhaps use of Oracle {\em In-Memory Database Cache (IMDB)} is appropriate.  The standard deployment uses the Apache Web Server, the Phusion Passenger module for Apache, and Oracle 10g or higher.

There are many companies that provide tools to build an online store,  {\em Yahoo! Stores}, or {\em Shopify} are examples.  TMS differs from these stores in several ways:
\begin{description}
 \item[Scalability]  TMS is designed to support a handful of products up to a million products in a scalable manner.  The scalability applies to both the customer who purchases items on the web site, as well as to the merchant who sets up and manages the site. 
\item[Performance] Keyword or description searches, product filtering, and navigation are all optimized by the use stored procedures in the Oracle database.  
\item[Bulk Operations] Although a TMS may have thousands of categories and a million products, administrative operations are provided that can affect large subtrees of categories.  For example, any subtree of the category tree can be easily reparented, renamed, deleted and so forth.  All the affected database tables will be automatically updated.  
\item[Payment Processing] Payment processing is currently supported through the PayPal and BrainTree payment gateways.  Final sales, authorization, full or partial capture, void of authorization, and refund are all supported.  
\item[Back Office Support] An asynchronous daemon listens for notifications from the gateways.  These notifications include transaction completions and reversals due to customer disputes.  The merchant (or administrator) can view a table of Orders that can be sorted in several ways, for example, orders that have been approved but not yet shipped.  He or she can edit the table to reflect the current state of the order.
If a product is given a ``low inventory'' theshold, TMS can be configured to send email to the merchant when the stock on hand drops below this threshold.
\item[Oracle Scalability] Because  TMS uses the Oracle Database, scalability via RAC clustering and/or Oracle TimesTen can be used to improve scalability. 
\item[Oracle Apps] Integration with other Oracle products such as Oracle Financials is possible.  This is optional, since TM does provide usable and effective back-office support on its own.
\item[Product Filters] Product ``filters'' that may be shown in the context of any category are automatically generated, based on all the filters that apply for all the products that are associated with the category.   This would be laborious and error-prone to do by hand.  In addition, the filters are maintained correctly during bulk operations.
\item[Shipping Costs] The TMS can contact UPS directly to present shipping choices and rates to the customer.
\item[Breadcrumb Trail] A breadcrumb trail is always presented to the user.  It includes the path through the tree of categories, as well as any searches that have been performed or filters that have been applied.  The customer can click on any element of the trail to go back to the view represented by that element.
\item[Open Source] TMS is open source and is built on the ``Ruby on Rails'' platform.
\end{description}

In this document, the {\em merchant} is the owner of the web-site.  The merchant is responsible for setting up and maintaining the web-site.  Only the merchant has access to the administrative portion of the web-site.  When the store is intially set up, the merchant will typically need to hire a programmer to do specific customizations and a designer to beautify the web-site.  TMS is provided with bare-bones styling.  The intent is that after the store is set up in this way,  the on-going maintenance of the site can be done by the merchant: defining the category tree,
defining attributes, defining product families, adding attributes to product families,  adding products to product families, defining the attribute values for a product, rearranging the category tree, fulfilling orders and flagging them as ``shipped'', voiding authorizations and so forth. 

On the other hand, the {\em customer} actually navigates/searches the web-site and purchases products. 

This guide discusses how the merchant can set up and maintain the store.

\section{Definitions}
There are a few very important concepts that need to be understood to set up the store.

\subsection{Product}
{\em Products} represent the actual types of items that are for sale in the store.  Thus a product will typically have an SKU or a part number.
When a product is added to a {\em product family} it may be given a value for each {\em product attribute} in the product family.  Alternatively,
the product may be edited later, and the values modified or assigned.  A product always belongs to exactly one product family.

\subsection{Category}
As in practically all web sites, navigation is done by traversing a tree-structured hierarchy of menus. The {\em category tree} defines this menu hierarchy. A category is best thought of as a \textit{navigation tab} rather than as a grouping of products.  As the customer navigates through the web site, he or she is always in the context of a category (the current category).  Only products in that category are visible to the customer. 

Interestingly, it is possible to build a TMS with no categories at all, except for the root category.  In this case, products can be searched and filtered, but there is no tree of products to navigate through. 

\subsection{Leaf Category}
A \emph{leaf} category is a category that has no subcategories. 

\subsection{Ancestor Category}
A category  $A$ is an \emph{ancestor} of category $B$ if the path from the root to $A$ includes $B$ and $B \neq A$. In particular, the root category is an ancestor of every category except itself.

\subsection{Product Family}
A {\em product family} is a container for a set of \textit{product attributes}. Every product belongs to exactly one product family.  The product family that the product belongs to determines the set of attributes that the product may have.  A product family may be associated with one or more leaf categories.

\subsection{Product Attribute}
A \textit{product attribute}, or simply \textit{attribute} defines some characteristic that products may have.   It is a self-contained concept.  It is not defined with respect to a product family, category, or product.  After it is defined, an attribute can be added to one or more product families.  (If a product family is like a database table, adding an attribute to a product family is like adding a column to the table.)

\subsection{Filters}
\textit{filters} are based on product attributes.  In fact, filtering is really an activity based on underlying product attribute information.  Filters are presented to the customer as a set of either \textit{enumerated choices} (for integer enum or string attributes) or \textit{ranges} (for currency, and integer attributes).  When the customer clicks on a choice or a range, only products having a value for that attribute that matches the choice or falls within the range are displayed.

\subsection{Visibility}
Assume that a category $C$ has a product family $F$ and that a product $P$ is in $F$.  That is not enough to make $P$ visible to the customer when he or she navigates to category $C$.  The product $P$ must also be configured to be {\em visible} in $C$.

\subsection{Display Priority}
A category may contain thousands of products.  These can not be shown to the customer all at once, although a paging facility is provided.  To support the idea of ``featured'' products or ``most popular'' products, the merchant can assign a priority to the product that determines how close to the first page the product is initally displayed.


\section{Consistency Rules}
\begin{enumerate}
\item A product family can be created as an independent entity.
\item A product attribute can be created as an independent entity.  
\item A given product attribute can be added to many product families.
\item A product attribute can be removed from a product family at any time.
\item A product can only be created with reference to a product family.
\item A product can be removed from a product family at any time.
\item A product always belongs to exactly one product family.
\item A product may (but is not required) to have a value for each attribute in the product family.
\item The anonymous top-level (or root) category always exists.
\item A product family may only be directly associated with a leaf category.
\item If a category has a product family, then all its ancestors also have the product family. 
\item The filters for a category are derived from the intersection of all the attributes in its product families.
\item A product may only be directly associated with a leaf category.
\item If a product is associated with a leaf category, then it is also associated with all the ancestor categories of the leaf.
\item A product may only be associated with a leaf category if it belongs to a product family associated with the leaf category.
\item A product will only be shown to the customer in the context of a category if the product is visible in the category.
\item Visibility may be eplicitly set only for products in leaf categories.
\item If a product is visible in a category, then it is visible in all the ancestor categories.
\end{enumerate}

\section{Overview of Store Initialization}

Assume that the store has already been set up, but that it is empty -- no products, no product families, etc.  What does the merchant actually do to set up the store?  There are many different order of operations that are possible.  The following is only an example.

\begin{enumerate}
\item Define the category tree.  This may be done by visiting the ``admin/categories'' URL.
\item Define one or more product families.  This may be done by visiting the ``admin/product\_families/new'' URL.  This page requires you to choose one or more leaf categories to associate with the new product family.
\item Define some attributes to add to your new product families.  This may be done by visiting the ``admin/product\_attributes/new'' URL.
On this page, choose at least a name, a globally unique name, and an attribute type. For an integer enum or string attribute fill in the discrete choices for the possible values of the attribute.  For a integer or currency attribute, the value fields represent the endpoints of the ranges (or intervals) that the user may filter on.  For example, if you enter 3, 10 100 in the first three numerically labeled fields, then you have defined intervals $[0, 3)$, $[3, 10)$, $[10, 100)$, and $[100, \infty)$.  Note that these intervals include the left endpoint but not the right.
\item Edit your product families to add some or all of the new attributes.  Visit the ``admin/product\_families'' URL and click on the name of the product family that you want to edit (add attributes to) from the left hand column of the table. You will see some information about the product family.  Click ``Edit Product Family'' to perform the edit.
\item Add your product family to one or more leaf categories.
\item You are now on the edit page for a particular product family.  On this page you can change any information about the product family, view the attributes already in the product family, and search for, add, or delete other attributes.
\item Next visit the products page by clicking on the ``products'' link.  First choose a product family for the product from the list in the left sidebar.  You will see a form to fill in attribute values (for the chosen product family) for this product.  Do this an click submit.  You will be returned to the same page.
\item Still on the ``edit product'' page you will see some choices for visibility paths.  These correspond to the leaf categories where the product family for this product is associated.  Select one or more of these paths and click submit.  Then the product will be visible in all the selected leaf categories and all ancestors.  You will be returned to the same page.
\item Still on the ``edit product'' page, you may upload photos.  These may be thumbnails, gallery photos, or full size.  By clicking on the ``edit photos'' link you can indicate which full size photo corresponds to which gallery photo.  
\end{enumerate}


\begin{center}
\begin{figure*}
\includegraphics[scale=0.35]{product-edit}
\caption{\label{product-edit}Edit Product Page}
\end{figure*}
\end{center}

\section{Product Family}
For example, we may have a product family called {\em Cameras} with attributes {\em Is\_Digital}, {\em Brand}, {\em Megapixels}, {\em Price}, {\em Optical\_Zoom}, {\em Condition}, {\em Avg\_Customer\_Review}, {\em View\_Finder\_Type}, {\em Display\_Size}, {\em Seller}, {\em Image\_Stabilization}, and {\em Auto\_Rewind}.  This product family is intended to include both digital and film cameras.  Note that not all the attributes are applicable to both types of cameras.

\section{Category}
 To avoid ambiguity, categories should may named by their full path in the hierarchy. I.e. \textit{/automotive/brakes/shoes} is a different category than \textit{/footwear/children/shoes}.

A product family must have a unique name, i.e. two product families can have the same name.

After a product family has been defined, products can be added to the product family.  In fact, when a product is first created, it must be assigned to a product family.  At that time (or later) values for that product can be assigned.  For example, if we create a product {\em Nikon N80} in the Cameras product family, we can assign the value \textit{false} to \textit{Is\_Digital}, the value \textit{true} to \textit{Auto\_Rewind},
but leave attributes that do not apply, such as \textit{Megapixels} blank.

A product is always assigned to exactly one product family.  It may help to think of a product family as a database table and the attributes of the product family as being the columns for that table.  Adding a product to a product family is like creating a row in this table.  [Note: this is not at all what the database schema is like!]

\subsection{Product Attributes}
A \textit{product attribute}, or simply \textit{attribute} defines some characteristic that products may have.   It is a self-contained concept.  It is not defined with respect to a product family, category, or product.  After it is defined, an attribute can be added to one or more product families.  (If a product family is like a database table, adding an attribute to a product family is like adding a column to the table.)

\subsubsection{Attribute Types}
Each product attribute has a type:
\begin{description}
\item[string] This is an enumerated  attribute.  The attribute defines its set of allowed values.  For example, a \textit{color} attribute may define values \textit{red}, \textit{green}, and \textit{blue}.
\item[integer] Any integer value $>= 0$ is allowed.
\item[integer enum] This is an enumerated attribute.  The attribute defines its set of allowed values.  For example, a \textit{rotation speed} attribute may define values \textit{7200} and \textit{15000}.
\item[currency] A price together with the currency type.
\end{description}

\subsubsection{Attribute Choices and Ranges}
In addition to having a type, an enumerated type defines
For the integer and currency attribute types, the \textit{ranges} is simply a set of contiguous intervals that partition $[0, \infty]$.

You can define the set of ranges or choices when the attribute is created, or you can edit the product attribute later.



\begin{wrapfigure}{R}{0.2\textwidth}
\begin{center}
\includegraphics[scale=0.4]{attribute-sidebar}
\end{center}
\caption{Filter Sidebar}
\end{wrapfigure}

\section{Product Visibility}
Product families restrict where in the category tree that that its associated products can be displayed.  Specifically, a product family can be assigned to one or more leaf categories.  Then any products that belong to this product family are eligible to be displayed to the customer in this leaf category as well as all its ancestors.

Whether or not the product \textit{is} actually displayed depends on the product itself.  For example, suppose that there is a leaf category called \textit{Closeouts}, and that every product family is added to this category.  This makes every product \textit{eligible} to be displayed in the Closeout category.  (It also means that few or no filters will be available to the customer when viewing this category -- see below).  Any products that truly are closeout items should be added to this category individually.

\subsection{Displayable and Displayed Product}
Within the context of a category, only a subset of all possible products can be shown to the user.  Such products are called {\em displayable} products.  Typically, not all displayable products are shown or {\em displayed} to the user.  The displayable concept limits what can be displayed.

\subsection{Filtering on Attributes}
Within every category context, the search filters may be shown.  Each filter must ``make sense'' for all the displayable products in the category.  Filters are based on {\em attributes}: select a certain color, select a certain size, etc.

\subsection{Product Family}
Products that have similar attributes are grouped into a {\em product family}.  Each product belongs to exactly one product family.  Since a product family is associated with a set of attributes, all the products in a product family share the same set of attributes.  When a product family is associated with a leaf category, all its products become displayable in that leaf category as well as all its ancestors, all the way up to the root category.  A given product family can be associated with more than one leaf category, and a given leaf category may be associated with more than one product family.

\section{Breadcrumb Trail}
At any point, the user can see the current category context via a breadcrumb trail.  This is a representation of the path from the root category to the current category.  In addition, any search or filters that have been applied to the current view are appended to the path in the order that the choices have been made.  The user may click on any component of the trail to revert to any past view, including search or filter components. Any number of filters may be consecutively applied to a category context or after a search. However, starting a new search {\em after} filter choices have been made removes all filter choices from the path --- the user view reverts to the last category context followed by the new search.  This is done to prevent confusing the user.  The user may have trouble keeping track of the meaning of ``search after filter''.  On the other hand, ``filter after search'' does seem to make more intuitive sense.

\section{Displayable Products}
Here is how the displayable products for a category $C$ are determined.  Let $\mathscr{P}$ denote all product families that are associated with a leaf category that is a descendent of $C$.  The displayable products for $C$ are all the products that belong to some product family in $\mathscr{P}$.  This is abbreviated $displayable(C)$
\par
Why is such a complicated definition used?  It is primarily to support filtering on attributes.  The same attribute filters apply for all the products in a product family (since all these products necessarily have the same attributes).  If we take all the products from a number of product families, then we can only filter on the attributes that are in common to all these product families.  Thus, as the number of product families increases, the number of available attributes that we can filter on decreases.  Towards the leaf categories many specific filters can be used.  Towards the root, only very generic attributes can be used as filters, such as ``price''.
\par
In an interior category, the displayable products are all the products that ``bubble up'' from the product families defined at its leaf descendants, and the attributes that are available to filter on are  the attributes that are in common across all these product families.

\section{Categories}
As a customer traverses the store he/she is always in the context of some particular category.  On first visiting the site, the customer is in the context of the {\em root category}.   The initial set of products that the merchant wants the customer to see are displayed in this category.

Below the root category are the {\em top-level categories}.  These are the categories that appear in the {\em navigation bar} when the customer is in the context of the root category.  The top-level categories may have subcategories.  Categories up to four levels deep are supported.  (It is believed at this time that a deeper hierarchy of categories is not needed due to the search/filter capabilities that are provided.  If each category has ten subcategories, then there are 10,000 categories.  At 100 products per category, this supports 1,000,000 products. )

The category context determines the search and filter choices that are presented to the customer.

A category that has no descendants is called a {\em leaf} node.

The (unnamed) top-level category always exists, but the merchant may choose not to create any other categories.  In this case, there are no navigation tabs.  Products may be found using filters and searches as described below.  This is a certainly a viable approach when there are only a few hundred products.

At the other extreme, no filters need be defined.  Products could be found exclusively by searches or navigation through the category tree.

\begin{figure*}
\includegraphics[scale=0.4]{categories-show}
\end{figure*}

\section{Searches}
When a search is conducted within the context of a category, the search results are taken from the displayable products (not the displayed products.)  Thus a search may reveal products that were previously hidden within the category.  Note that this won't happen for a leaf category.  All the displayable products are always displayed at a leaf category.

\section{Association Invariants for Categories}\label{association-invariants}
Every category has three types of associations ---  a category is associated to zero or more product families, zero or more products, and zero or more family attributes.
For brevity, instead of saying ``the product families associated with a category'', we sometimes say the ``the product families of the category'', or even ``the category's product families''.  Similar phraseology is used for products and family attributes. There are four invariants (conditions that must always be true):
\begin{enumerate}
\item For any non-leaf category, its product families are the union of the product families of its children.
\item For any category, its attributes are the intersection of the attributes of its product families.
\item For any non-leaf category, its products are the union of the products of its children.
\item For any category, each of its products must belong to exactly one of the product families of the category.   
\end{enumerate}
To explain Invariant (2) further: a given category has a number of product families.  Each product family has a number of attributes, that we're thinking of as a set.  Take the intersection of all these sets to get the set of attributes associated with the category.   This applies even for leaf categories.  
\par
For products, it helps to think of the product families of a category as a {\em restriction} on the products that can be associated with the category.  A category can have a given product only if the product belongs to one of the category's product families.  
\par
For a non-leaf category, all three kinds of associations are {\em completely determined} by its children.  Once we know the product families for each of the child categories, the product families of the parent are completely determined.  Further, once we know the product families of any category, its attributes are  completely determined.   Invariant (1) says how to compute the product families of the parent from its children.  Invariant (2) says how to compute the attributes of any category knowing its product families.  Invariant (3) says how to compute the products of a non-leaf node from the products of its children.  Invariant (4) restricts the set of products that can be associated with a category.
\par
Part of the rationale for the for Invariant (2) is that the attributes of a category should be valid for all the products in the category.  Since the products are the union of the products of the children, we must take the intersection of the attributes of the children to get the attributes that are valid for all products in the parent category.
\section{Association Policies}\label{association-rules}
The general principle is that all of the product familes, product attributes, and products of a non-leaf category are {\em completely determined} by its children, as described in Section \ref{association-invariants}.  That is, we can compute those associations for the parent if we know what associations each of its children have.  Thus administrative operations to change these associations can only operate on leaf categories, and then the associations of all of the ancestor categories is automatically recomputed.  This section describes some policies that are followed to maintain the invariants.
\subsection{Product Families}
\begin{enumerate}
\item A product family can be added or removed to any leaf category.
\item If a product family is added to or removed from  a leaf category, then the product families and family attributes of that category and all its ancestors must be recomputed.
\item Multiple product families may be associated with to a given leaf category.
\item A given product family may be associated with multiple leaf categories.
\item It is not possible to directly add or remove a product family from any non-leaf category.
\end{enumerate}
Thus the store administrator can assign product families in any manner to leaf categories.  All the association invariants will be automatically maintained.
\subsection{Product Attributes}
\begin{enumerate}
\item A product attribute can be associated with zero or more product familes.
\item A product family can have many product attributes.
\item If a product attribute is added to or removed from a product family, the leaf nodes having that product family must be found, and their attributes recomputed.  The attributes must also be recomputed for all ancestors of these leaves.
\end{enumerate}
\subsection{Products}
\begin{enumerate}
\item A product must be associated to exactly one product family.
\item If the product family of a product is associated with a given leaf category, then the product may be associated with that leaf category as an administrative operation.
\end{enumerate}

\section{Visibility and Display Priority}
For a product $P$ to be {\em visible} in a given category $C$, it must be associated with $C$.  Products can't be directly associated with non-leaf categories, they can only be associated with a leaf as an administrative operation.  In addition, the product family of the category must first be associated with the leaf.  Once both of these are done, the product will appear in all the ancestor categories of the leaf.
\par
A {\em visibility\_path} for a product is simply the path through the category tree to a leaf which has (is associated to) the product family of the product.  The web page for product management allows the user to choose the visiblity paths for the product.  The idea is that just because a product is {\em eligible} to be visible at a leaf (and ipso facto, the ancestors of the leaf) it doesn't mean it should be.  For example, a {\em closeouts} leaf category may contain dozens of product families, thereby making many products eligible to be placed in this category.  But we may still want only a few products to be visible it this category.  
\par
However, there could be many thousands of products associated with $C$.  The product display is paginated. Each product has a $display\_priority$ attribute that affects how early in the pagination the product should appear.  Products with lower priority values will occur earlier in the pagination than products with higher priority values.
\par
In summary, to make a product visible in a leaf category there are two steps: (1) make sure that the product family of the category is associated with the leaf, and (2) add the product family to the leaf by choosing the path to the leaf as a visibility path of the product.  Then optionally assign a display priority.  The product will then be visible in all ancestor categories of the leaf. 

\section{Category Operations}
The tree of categories may be modified with the operations described below.  For brevity, when we refer to the {\em associations} of a category, we mean all of its product family associations, product attribute associations, and product associations.  All the association rules described in Section \ref{association-rules} must be followed.

\subsection{Create}
Create a new category and add it as a child of any category in the tree.  The new category is a {\em leaf} category.
\par
If the parent category was a leaf category, then all of its associations are copied to the newly created child.  If the parent category was not a leaf category, then no associations are added to the child -- it is an empty category.   In either case, the associations of the parent remain unchanged.

\subsection{Delete}
Delete a category from the tree. All associations to the category (i.e. products, product families, and product attributes) will be deleted.  None of these other objects are deleted, only their {\em association} to the category being deleted.  Any category, except for the root category, may be deleted at any time.  If a leaf category is being deleted and some product family associated with the leaf has no association to any other category, then no products of this product family will be visible anywhere in the category tree.  It is up to the administrator to associate the product family with some other leaf, as well as to establish the visibility paths to make the products in the product family visible.
\par
 If a non-leaf category is being deleted, then its child categories become children of the category's parent node.  The associations of the parent are unchanged.
\par
If a leaf category is being deleted, then the associations that were contributed to the parent only by this leaf category are removed from the parent.  If some other child of the parent has an association to a given product family, for example, that association would not be removed from the parent even if the child being deleted is associated with the same product family.  This policy is necessary to maintain the rule that the associations of a parent are completely determined by the associations of its children.
\par
In the case where we are deleting a leaf and the parent itself is a leaf, all the parent associations will be unchanged.  The products that were visible before in the parent continue to be visible.  Thus in this case, create and delete are inverses.  One can create and delete a child category of a leaf parent without affecting the parent associations.
\par
Note that it is never possible to preserve {\em all} the associations in the parent when the parent has other children.

\subsection{Reparent}
To reparent a category means to move it and all its descendants (i.e. the subtree rooted at that category) to be a child of a different parent category. 
\par
What happens to the associations of the old parent?  The associations of the old parent are computed from its remaining children, if any.  In the case where the old parent has no remaining children, it will become a leaf category with no associations.  In either case, the associations of all the ancestors of the old parent are also recomputed.
\par
What happens to the associations of the new parent?  The associations of the reparented category are merged with those of the new parent.
\par
The new parent category must not be a leaf, or the operation fails.  One can get this effect, if desired, by first creating a leaf child of the new parent.  Then reparent the old parent to the new, then finally remove the temporary leaf category.  This sequence of steps forces the administrator to be very conscious of the associations that are being removed (by deleting the temporary leaf category).

\subsection{Rename}
Any category can be renamed at any time.  The only restriction is that two siblings of the same parent can not have the same name.  

\subsection{Add Product Family}


\subsection{Remove Product Family}

\section{Database Schema}
It is helpful to understand the part of the database schema that relates to how the store is configured.  The most important tables are $products$, $product\_attributes$, $product\_families$, and $categories$.  In Figure~\ref{schema02}, these tables are denoted by the corresponding model names in Rails.  For example, the $products$ table in the database corresponds to a model named Product.  An arrow indicates a \emph{belongs-to} relationship.  For example, the arrow from Product to ProductFamily indicates that each Product belongs to exactly one ProductFamily.  There are four join tables in the schema.  In the figure, these have a red background.  These are used to handle many-to-many relationships.  For example, one Product can have many Categories, and one Category can have many Products.  
\par
The $category\_attributes$ table may be completely computed from the other tables.  It exists to make some database queries more efficient.  It answers the question: ``Given a Category, what are all the ProductAttributes that are in common to all the Products that may be in the Category?''  At the other extreme, the $family\_attributes$ table is completely specified by the admistrator as the store is built or maintained.  It is modified as the administrator adds or removes ProductAttributes from a ProductFamily.  The remaining two join tables $category\_products$ and $category\_families$ are hybrids, they are partly specified and partly computed.  The $category\_products$ table is used to answer this question: ``Given a Category, what are all the Products in the Category?''.  Similarly, the $category\_familes$ table is used to answer the question: ``Given a Category, what are all the ProductFamilies in the Category?''.  


\begin{figure*}
\includegraphics[scale=0.9]{schema}
\caption{\label{schema02}Database Schema}
\end{figure*}


% \end{multicols}
\end{document}

